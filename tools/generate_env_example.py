from __future__ import annotations

"""
Generate the repo-root .env.example by statically inspecting the codebase for env var usage.

This script intentionally:
- reads source files only (no imports / execution)
- outputs variable names only (no values)
- groups variables with brief comments

Usage:
  python3 tools/generate_env_example.py
"""

import re
from dataclasses import dataclass
from pathlib import Path


REPO_ROOT = Path(__file__).resolve().parents[1]
OUT_FILE = REPO_ROOT / "backend" / ".env.example"


SKIP_DIRS = {
    ".git",
    ".cursor",
    "logs",
    "backend/venv",
    "backend/.venv",
}


ENV_PATTERNS: list[re.Pattern[str]] = [
    # Python
    re.compile(r"os\.getenv\(\s*['\"]([A-Z0-9_]+)['\"]"),
    re.compile(r"os\.environ\.get\(\s*['\"]([A-Z0-9_]+)['\"]"),
]

ALLOWED_PREFIXES = (
    "AWS_",
    "S3_",
    "DB_",
    "JWT_",
    "ACCESS_",
    "REFRESH_",
    "EMAIL_",
    "SMTP_",
    "FROM_",
    "RESEND_",
    "CORS_",
    "PUBLIC_",
    "FRONTEND_",
    "ENABLE_",
    "DOC_",
    "MAX_",
    "PASSWORD_",
)

ALLOWED_EXACT = {"ENV"}


@dataclass(frozen=True)
class Group:
    title: str
    comment: str
    keys: tuple[str, ...]


GROUPS: list[Group] = [
    Group("General", "General environment switches.", ("ENV",)),
    Group(
        "Database (Postgres)",
        "Backend database connection.",
        ("DB_HOST", "DB_PORT", "DB_NAME", "DB_APP_USER", "DB_APP_PASSWORD", "DB_MIGRATOR_USER", "DB_MIGRATOR_PASSWORD", "DB_SSLMODE"),
    ),
    Group(
        "Password policy",
        "Password complexity + rotation controls.",
        ("PASSWORD_MIN_LENGTH", "PASSWORD_MAX_AGE_DAYS"),
    ),
    Group("CORS", "Comma-separated list of allowed origins for the backend.", ("CORS_ORIGINS",)),
    Group("Auth / JWT", "Backend authentication settings.", ("JWT_SECRET", "JWT_ALGORITHM", "ACCESS_TOKEN_EXPIRE_MINUTES")),
    Group(
        "Refresh tokens",
        "Refresh token / cookie settings.",
        (
            "REFRESH_TOKEN_EXPIRE_HOURS",
            "REFRESH_COOKIE_NAME",
            "REFRESH_COOKIE_SAMESITE",
            "REFRESH_COOKIE_SECURE",
            "REFRESH_COOKIE_PATH",
            "REFRESH_COOKIE_DOMAIN",
        ),
    ),
    Group(
        "Email (provider selection)",
        "EMAIL_PROVIDER defaults to resend when unset. smtp is a legacy alias for gmail.",
        ("EMAIL_PROVIDER",),
    ),
    Group(
        "Email (From address)",
        "FROM_EMAIL is used only for providers: ses, resend. Do not use it for gmail/smtp.",
        ("FROM_EMAIL",),
    ),
    Group(
        "Email (Resend)",
        "Used when EMAIL_PROVIDER=resend.",
        ("RESEND_API_KEY",),
    ),
    Group(
        "Email (Gmail/SMTP)",
        "Used when EMAIL_PROVIDER=gmail (or legacy smtp). From address is SMTP_FROM_EMAIL.",
        ("SMTP_HOST", "SMTP_PORT", "SMTP_USERNAME", "SMTP_PASSWORD", "SMTP_FROM_EMAIL", "SMTP_USE_TLS", "SMTP_USE_SSL"),
    ),
    Group(
        "Email verification",
        "Email verification link settings.",
        ("EMAIL_VERIFY_TOKEN_EXPIRE_HOURS", "FRONTEND_BASE_URL"),
    ),
    Group("Server URLs", "Used to build server-side links in some flows.", ("PUBLIC_BASE_URL",)),
    Group("Rate limiting", "SlowAPI rate limiting toggle.", ("ENABLE_RATE_LIMITING",)),
    Group("Uploads", "Upload guardrails (max file size etc.).", ("MAX_UPLOAD_BYTES", "MAX_PENDING_UPLOADS_PER_JOB")),
    Group("AWS (S3 uploads)", "S3 bucket + prefix for document uploads.", ("AWS_REGION", "S3_BUCKET_NAME", "S3_PREFIX")),
    Group("Internal callbacks", "Shared secret for internal Lambda callbacks.", ("DOC_SCAN_SHARED_SECRET",)),
    Group("Frontend (Vite)", "Frontend environment variables (Vite).", ("VITE_API_BASE_URL",)),
]


def _iter_source_files() -> list[Path]:
    files: list[Path] = []
    # Backend-only .env.example: scan backend sources only.
    for p in (REPO_ROOT / "backend").rglob("*"):
        if not p.is_file():
            continue
        rel = p.relative_to(REPO_ROOT).as_posix()
        if any(rel == d or rel.startswith(d + "/") for d in SKIP_DIRS):
            continue
        if p.suffix.lower() not in {".py", ".md"}:
            continue
        files.append(p)
    return files


def _extract_env_keys(text: str) -> set[str]:
    found: set[str] = set()
    for pat in ENV_PATTERNS:
        for m in pat.finditer(text):
            key = m.group(1)
            if key:
                if key in ALLOWED_EXACT or key.startswith(ALLOWED_PREFIXES):
                    found.add(key)
    return found


def _scan() -> set[str]:
    keys: set[str] = set()
    for f in _iter_source_files():
        try:
            text = f.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            continue
        keys |= _extract_env_keys(text)
    return keys


def _render(found: set[str]) -> str:
    lines: list[str] = []
    lines.append("# Auto-generated by tools/generate_env_example.py")
    lines.append("# Names only. DO NOT put secrets in this file.")
    lines.append("")

    used = set()
    for g in GROUPS:
        present = [k for k in g.keys if k in found]
        if not present:
            continue
        lines.append(f"## {g.title}")
        lines.append(f"# {g.comment}")
        for k in sorted(set(present)):
            lines.append(k + "=")
            used.add(k)
        lines.append("")

    return "\n".join(lines).rstrip() + "\n"


def main() -> None:
    found = _scan()
    content = _render(found)
    OUT_FILE.parent.mkdir(parents=True, exist_ok=True)
    OUT_FILE.write_text(content, encoding="utf-8")
    print(f"Wrote {OUT_FILE.relative_to(REPO_ROOT)} with {len(found)} variables.")


if __name__ == "__main__":
    main()


