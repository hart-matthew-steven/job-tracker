from __future__ import annotations

"""
Generate the repo-root .env.example by statically inspecting the codebase for env var usage.

This script intentionally:
- reads source files only (no imports / execution)
- outputs variable names only (no values)
- groups variables with brief comments

Usage:
  python3 tools/generate_env_example.py
"""

import re
from dataclasses import dataclass
from pathlib import Path


REPO_ROOT = Path(__file__).resolve().parents[1]
OUT_FILE = REPO_ROOT / "backend" / ".env.example"


SKIP_DIRS = {
    ".git",
    ".cursor",
    "logs",
    "backend/venv",
    "backend/.venv",
}


ENV_PATTERNS: list[re.Pattern[str]] = [
    # Python
    re.compile(r"os\.getenv\(\s*['\"]([A-Z0-9_]+)['\"]"),
    re.compile(r"os\.environ\.get\(\s*['\"]([A-Z0-9_]+)['\"]"),
]

ALLOWED_PREFIXES = (
    "AWS_",
    "S3_",
    "DB_",
    "COGNITO_",
    "EMAIL_",
    "RESEND_",
    "CORS_",
    "ENABLE_",
    "DOC_",
    "MAX_",
    "PASSWORD_",
    "GUARD_",
    "TURNSTILE_",
    "FRONTEND_",
)

ALLOWED_EXACT = {"ENV"}


@dataclass(frozen=True)
class Group:
    title: str
    comment: str
    keys: tuple[str, ...]


GROUPS: list[Group] = [
    Group("General", "General environment switches.", ("ENV",)),
    Group(
        "Database (Postgres)",
        "Backend database connection.",
        ("DB_HOST", "DB_PORT", "DB_NAME", "DB_APP_USER", "DB_APP_PASSWORD", "DB_MIGRATOR_USER", "DB_MIGRATOR_PASSWORD", "DB_SSLMODE"),
    ),
    Group(
        "Password policy",
        "Password complexity requirements.",
        ("PASSWORD_MIN_LENGTH",),
    ),
    Group("CORS", "Comma-separated list of allowed origins for the backend.", ("CORS_ORIGINS",)),
    Group(
        "Cognito",
        "Amazon Cognito configuration.",
        ("COGNITO_REGION", "COGNITO_USER_POOL_ID", "COGNITO_APP_CLIENT_ID", "COGNITO_JWKS_CACHE_SECONDS"),
    ),
    Group("Rate limiting", "SlowAPI rate limiting toggle.", ("ENABLE_RATE_LIMITING",)),
    Group(
        "GuardDuty Malware Protection",
        "Feature flag for GuardDuty malware callbacks.",
        ("GUARD_DUTY_ENABLED",),
    ),
    Group(
        "Bot protection",
        "Cloudflare Turnstile configuration.",
        ("TURNSTILE_SITE_KEY", "TURNSTILE_SECRET_KEY"),
    ),
    Group("Uploads", "Upload guardrails (max file size etc.).", ("MAX_UPLOAD_BYTES", "MAX_PENDING_UPLOADS_PER_JOB")),
    Group("AWS (S3 uploads)", "S3 bucket + prefix for document uploads.", ("AWS_REGION", "S3_BUCKET_NAME", "S3_PREFIX")),
    Group("Internal callbacks", "Shared secret for internal Lambda callbacks.", ("DOC_SCAN_SHARED_SECRET",)),
    Group(
        "Email verification",
        "Resend-powered verification codes.",
        (
            "EMAIL_VERIFICATION_ENABLED",
            "EMAIL_VERIFICATION_CODE_TTL_SECONDS",
            "EMAIL_VERIFICATION_RESEND_COOLDOWN_SECONDS",
            "EMAIL_VERIFICATION_MAX_ATTEMPTS",
            "RESEND_API_KEY",
            "RESEND_FROM_EMAIL",
            "FRONTEND_BASE_URL",
        ),
    ),
]


def _iter_source_files() -> list[Path]:
    files: list[Path] = []
    # Backend-only .env.example: scan backend sources only.
    for p in (REPO_ROOT / "backend").rglob("*"):
        if not p.is_file():
            continue
        rel = p.relative_to(REPO_ROOT).as_posix()
        if any(rel == d or rel.startswith(d + "/") for d in SKIP_DIRS):
            continue
        if p.suffix.lower() not in {".py", ".md"}:
            continue
        files.append(p)
    return files


def _extract_env_keys(text: str) -> set[str]:
    found: set[str] = set()
    for pat in ENV_PATTERNS:
        for m in pat.finditer(text):
            key = m.group(1)
            if key:
                if key in ALLOWED_EXACT or key.startswith(ALLOWED_PREFIXES):
                    found.add(key)
    return found


def _scan() -> set[str]:
    keys: set[str] = set()
    for f in _iter_source_files():
        try:
            text = f.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            continue
        keys |= _extract_env_keys(text)
    return keys


def _render(found: set[str]) -> str:
    lines: list[str] = []
    lines.append("# Auto-generated by tools/generate_env_example.py")
    lines.append("# Names only. DO NOT put secrets in this file.")
    lines.append("")

    used = set()
    for g in GROUPS:
        present = [k for k in g.keys if k in found]
        if not present:
            continue
        lines.append(f"## {g.title}")
        lines.append(f"# {g.comment}")
        for k in g.keys:
            if k in present and k not in used:
                lines.append(k + "=")
                used.add(k)
        lines.append("")

    return "\n".join(lines).rstrip() + "\n"


def main() -> None:
    found = _scan()
    content = _render(found)
    OUT_FILE.parent.mkdir(parents=True, exist_ok=True)
    OUT_FILE.write_text(content, encoding="utf-8")
    print(f"Wrote {OUT_FILE.relative_to(REPO_ROOT)} with {len(found)} variables.")


if __name__ == "__main__":
    main()


